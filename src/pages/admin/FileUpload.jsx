import React, { useState, useEffect, useRef } from "react";
import { useSelector } from "react-redux";
import api from "../../api/axiosInstance";
import alertService from "../../services/alertService"; // Re-using existing alert service
import { DatePicker, Typography, Select, Modal, Spin } from "antd"; // Import Modal and Spin
import moment from "moment";
import "../../styles/FileUpload.css"; // Ensure you have this CSS file

const FileUpload = () => {
  // State management
  const [documentTitle, setDocumentTitle] = useState("");
  const [selectedClass, setSelectedClass] = useState("");
  const [file, setFile] = useState(null);
  const [fileName, setFileName] = useState("");
  const [formData, setFormData] = useState({});
  const [classStructures, setClassStructures] = useState([]);
  const [classOptions, setClassOptions] = useState([]);
  const [selectedClassFields, setSelectedClassFields] = useState([]);
  const [errors, setErrors] = useState({});
  const [isFormValid, setIsFormValid] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [isAccordionOpen, setIsAccordionOpen] = useState(false);
  const [selectedStorageLocation, setSelectedStorageLocation] = useState("");
  // NEW STATE: For the loading modal
  const [isUploadingModalVisible, setIsUploadingModalVisible] = useState(false);

  const { Title } = Typography;
  const authToken =
  useSelector((state) => state.auth.user?.authToken) ||
  localStorage.getItem("authToken");
  const authState = useSelector((state) => state.auth.user);
  const userId = authState?.userId;
  const fileInputRef = useRef(null);

  // NEW STATE: To control the Reference Key input and logic
const [requiresUserReferenceKey, setRequiresUserReferenceKey] = useState(false);
const [referenceKey, setReferenceKey] = useState("");
// NEW: Reference key combination state
const [referenceKeyCombination, setReferenceKeyCombination] = useState([]);
const [isReferenceKeyAutoGenerated, setIsReferenceKeyAutoGenerated] = useState(false);

// ðŸ†• Document Type States
const [mainDocumentType, setMainDocumentType] = useState("");
const [subDocumentType, setSubDocumentType] = useState("");


  // Same validation from GenerateClass
  const validateValue = (type, value) => {
  if (!value || value.toString().trim() === "") return true; // Empty handled by required

    switch (type) {
      case "String":
        return true;
      case "Integer": {
        const intRegex = /^-?\d{1,10}$/;
        if (!intRegex.test(value)) return false;
        const num = Number(value);
        return num >= -2147483648 && num <= 2147483647;
      }
      case "BigInteger": {
        const bigIntRegex = /^-?\d{1,19}$/;
        if (!bigIntRegex.test(value)) return false;
        try {
          const num = BigInt(value);
          return (
            num >= BigInt("-9223372036854775808") &&
            num <= BigInt("9223372036854775807")
          );
        } catch {
          return false;
        }
      }
    case "Double": {
      const doubleRegex = /^-?\d+(\.\d+)?([eE][-+]?\d+)?$/;
      if (!doubleRegex.test(value.toString())) return false;
      const num = Number(value);
      if (isNaN(num)) return false;
      return (
        Math.abs(num) >= Number.MIN_VALUE &&
        Math.abs(num) <= Number.MAX_VALUE &&
        value.toString().replace(/[-.eE+]/g, "").length <= 15
      );
    }

      case "BigDecimal": {
        const bigDecimalRegex = /^-?\d+(\.\d+)?$/;
        return bigDecimalRegex.test(value);
      }
      case "Boolean":
        return ["true", "false"].includes(value.trim().toLowerCase());
      case "LocalDate":
        return /^\d{4}-\d{2}-\d{2}$/.test(value);
      case "LocalDateTime":
        return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/.test(value);
      default:
        return true;
    }
  };


  // Function to fetch class structures from the API
  useEffect(() => {
    if (!authToken) return;

    const fetchClassNames = async () => {
      try {
        const { data } = await api.get(`/candocspro/load-class/${userId}`);
        setClassStructures(data);

        const filteredNames = data
          .map((item) => item.className.split(".").pop())
          .filter((name) => name !== "Structure");
        setClassOptions(filteredNames);
      } catch (err) {
        console.error("Error fetching class names:", err);
        alertService.error("Error", "Could not load class names");
      }
    };
    fetchClassNames();
  }, [authToken]);

  // Validation logic
  useEffect(() => {
    validateForm();
  }, [selectedClass, documentTitle, file, formData]);

  const validateForm = () => {
    let formIsValid = true;
    const newErrors = {};

    if (!selectedClass) {
      newErrors.selectedClass = "Please select a class";
      formIsValid = false;
    }

    if (!documentTitle.trim()) {
      newErrors.documentTitle = "Document title is required";
      formIsValid = false;
    }

    if (!selectedStorageLocation) {
      newErrors.storageAreaId = "A storage location is required";
      formIsValid = false;
    }

    if (!file) {
      newErrors.file = "Please select a file";
      formIsValid = false;
    }

    // NEW: Reference Key Validation
        if (requiresUserReferenceKey && !referenceKey.trim()) {
            newErrors.referenceKey = "Reference Key is required for this class";
            formIsValid = false;
        }

    selectedClassFields.forEach((fieldName) => {
      const selectedClassData = classStructures.find(
        (cls) => cls.className.split(".").pop() === selectedClass
      );
      const field = selectedClassData?.fields[fieldName];
      const value = formData[fieldName];

      if (field?.mandatory && (!value || value.toString().trim() === "")) {
        newErrors[fieldName] = `${fieldName} is required`;
        formIsValid = false;
      }

      if (value && !validateValue(field?.type, value)) {
        newErrors[fieldName] = `${fieldName} must be a valid ${field?.type}`;
        formIsValid = false;
      }

    });


    setErrors(newErrors);
    setIsFormValid(formIsValid);
    return formIsValid;
  };


const handleClassChange = async (e) => {
  const className = e.target.value;
  setSelectedClass(className);
  setErrors({});
  setIsAccordionOpen(!!className);

  const selectedClassData = classStructures.find(
    (c) => c.className.split(".").pop() === className
  );

  if (selectedClassData) {
    const fields = Object.keys(selectedClassData.fields).filter(
      (field) => field !== "id" && field !== "guid" && field !== "storageAreaId"
    );
    setSelectedClassFields(fields);


// NEW: Check for reference key configuration
const isRefKeyCombination = selectedClassData.referenceKeyConfig?.isReferenceKey === true;
setRequiresUserReferenceKey(!isRefKeyCombination);

// Always clear old reference key when switching classes
setReferenceKey("");


    const initialData = {};
    fields.forEach((field) => {
      const fieldDef = selectedClassData.fields[field];

      if (fieldDef?.type === "Boolean") {
        initialData[field] = fieldDef.value === true ? "true" : "false";
      } else if (fieldDef?.value !== null && fieldDef?.value !== undefined) {
        initialData[field] = String(fieldDef.value);
      } else {
        initialData[field] = "";
      }
    });
    setFormData(initialData);

    // --- NEW: Fetch storageAreaId from backend ---
// --- NEW: Fetch class configuration and handle reference key logic ---
if (authToken) {
  try {
    const { data } = await api.post(
      "/candocspro/class-config",
      null,
      {
        params: { className },
        headers: { Authorization: `Bearer ${authToken}` },
      }
    );

    if (data && data.storageAreaId) {
      setSelectedStorageLocation(data.storageAreaId);
    } else {
      setSelectedStorageLocation("");
    }

    // ðŸ§  NEW LOGIC: Handle Reference Key Configuration
    if (data && data.isReferenceKey === true) {
      // Reference key is auto-generated â†’ show combination info
      setIsReferenceKeyAutoGenerated(true);
      setRequiresUserReferenceKey(false);
      setReferenceKeyCombination(data.referenceKeyCombination || []);
    } else {
      // Reference key must be entered manually
      setIsReferenceKeyAutoGenerated(false);
      setRequiresUserReferenceKey(true);
      setReferenceKeyCombination([]);
    }

  } catch (err) {
    console.error("Error fetching class config:", err);
    alertService.error("Error", "Could not load storage location or reference key config.");
    setSelectedStorageLocation("");
    setIsReferenceKeyAutoGenerated(false);
    setReferenceKeyCombination([]);
  }
}

  } else {
    setSelectedClassFields([]);
    setFormData({});
    setSelectedStorageLocation("");
  }
};


// ðŸ§© Dropdown options for Main & Sub Document Type
const documentTypeOptions = {
  Identity: ["Aadhar", "PAN", "Driving License", "Voter ID"],
  Certificate: ["10th Marksheet", "12th Marksheet", "UG Consolidate", "PG Consolidate"],
};

const mainTypeOptions = Object.keys(documentTypeOptions);
const subTypeOptions = mainDocumentType ? documentTypeOptions[mainDocumentType] : [];


  // Handle input changes for dynamic fields
  const handleInputChange = (fieldName, value) => {
    const updatedFormData = {
      ...formData,
      [fieldName]: value,
    };
    setFormData(updatedFormData);
  };

  // Handle file selection
  const handleFileChange = (e) => {
    const selectedFile = e.target.files[0];
    setFile(selectedFile);
    setFileName(selectedFile ? selectedFile.name : "");
  };


// Function to render dynamic fields with appropriate types

const handleSubmit = async (e) => {
  e.preventDefault();

  if (!validateForm()) {
    alertService.error(
      "Validation Error",
      "Please fill in all required fields correctly."
    );
    return;
  }

  // ðŸš« Stop upload if reference key is required but missing
if (requiresUserReferenceKey && !referenceKey.trim()) {
  alertService.error(
    "Validation Error",
    "Reference Key is required for this class."
  );
  return;
}


  if (!authToken) {
    alertService.error(
      "Error",
      "Authentication token missing. Please log in again."
    );
    return;
  }

  if (!selectedStorageLocation) {
    alertService.error(
      "Error",
      "Storage location is missing. Please select a class first."
    );
    return;
  }

  setIsUploadingModalVisible(true);
  setUploading(true);

  try {
    const selectedClassStructure = classStructures.find(
      (cls) => cls.className.split(".").pop() === selectedClass
    );

    if (!selectedClassStructure) {
      alertService.error("Error", "Selected class structure not found.");
      return;
    }

    const data = new FormData();

  // Document object (UPDATED: Conditional referenceKey)
            const documentObject = {
                documentTitle: documentTitle,
            };
            
            // If the class does *not* use a combination, send the user-entered referenceKey.
            // If it *does* use a combination, send null.
            documentObject.referenceKey = requiresUserReferenceKey ? referenceKey : null;
    const documentBlob = new Blob([JSON.stringify(documentObject)], {
      type: "application/json",
    });
    data.append("document", documentBlob);

    // ðŸ†• Validate Main and Sub Document Types
if (!mainDocumentType) {
  newErrors.mainDocumentType = "Please select a Main Document Type";
  formIsValid = false;
}

if (!subDocumentType) {
  newErrors.subDocumentType = "Please select a Sub Document Type";
  formIsValid = false;
}


    // Custom data object (âœ… inject storageAreaId if backend expects it)
    const customDataObject = { ...formData };
    if (!customDataObject.storageAreaId) {
      customDataObject.storageAreaId = selectedStorageLocation;
    }
      // ðŸ†• Include document type fields
      customDataObject.mainDocumentType = mainDocumentType;
      customDataObject.subDocumentType = subDocumentType;
    const customDataBlob = new Blob([JSON.stringify(customDataObject)], {
      type: "application/json",
    });
    data.append("customData", customDataBlob);

    // File
    data.append("file", file);

    // Axios POST request with query params
    const { data: responseData } = await api.post(
      "/candocspro/upload-file",
      data,
      {
        headers: {
          "Content-Type": "multipart/form-data",
          Authorization: `Bearer ${authToken}`,
        },
        params: {
          storageAreaId: selectedStorageLocation,           // âœ… always top-level
          className: selectedClassStructure.className,     // âœ… always top-level
          documentVersionId: 1,                             // âœ… always top-level
        },
      }
    );

    console.log("Upload successful:", responseData);
    alertService.success("Success", "Document uploaded successfully!");

    // Reset form
    setSelectedClass("");
    setDocumentTitle("");
    setFile(null);
    setReferenceKey("");
    setRequiresUserReferenceKey(false);
    setFileName("");
    setFormData({});
    setSelectedClassFields([]);
    setErrors({});
    setIsFormValid(false);
    setIsAccordionOpen(false);
    setSelectedStorageLocation("");
    // ðŸ†• Reset Main & Sub Document Type
    setMainDocumentType("");
    setSubDocumentType("");
    if (fileInputRef.current) fileInputRef.current.value = "";

  } catch (error) {
    console.error("Upload error:", error);
    alertService.error("Error", "Failed to upload document. Please try again.");
  } finally {
    setIsUploadingModalVisible(false);
    setUploading(false);
  }
};



const renderField = (field) => {
    const selectedClassData = classStructures.find(
      (cls) => cls.className.split(".").pop() === selectedClass
    );
    const fieldData = selectedClassData?.fields[field];
    const fieldValue = fieldData?.value;

    if (!fieldData) return null;

    // Determine the placeholder text
    const placeholderText = fieldValue !== null
      ? ` ${fieldValue}`
      : `Enter ${field}`;


switch (fieldData.type) {
      case "LocalDate":
  return (
    <DatePicker
      value={formData[field] ? moment(formData[field], "YYYY-MM-DD") : null}
      onChange={(date, dateString) => handleInputChange(field, dateString)}
      format="YYYY-MM-DD"
      placeholder={placeholderText} // fieldValue shows here
      className={errors[field] ? "error" : ""}
    />
  );

case "LocalDateTime":
  return (
    <DatePicker
      showTime={{ format: "HH:mm:ss" }}
      value={formData[field] ? moment(formData[field], "YYYY-MM-DDTHH:mm:ss") : null}
      onChange={(date) =>
        handleInputChange(field, date ? date.format("YYYY-MM-DDTHH:mm:ss") : "")
      }
      format="YYYY-MM-DD HH:mm:ss"
      placeholder={placeholderText} // fieldValue shows here
      className={errors[field] ? "error" : ""}
    />
  );

case "Boolean":
  return (
    <label className="checkbox-wrapper">
      <input
        type="checkbox"
        name={field}
        checked={formData[field] === "true" || formData[field] === true}
        onChange={(e) =>
          handleInputChange(field, e.target.checked ? "true" : "false")
        }
      />
    </label>
  );


Â  Â  Â  case "Integer":
Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  type="number"
Â  Â  Â  Â  Â  Â  value={formData[field] || ""}
Â  Â  Â  Â  Â  Â  onChange={(e) => {
Â  Â  Â  Â  Â  Â  Â  const val = e.target.value;
Â  Â  Â  Â  Â  Â  Â  if (/^-?\d{0,10}$/.test(val)) { // max 10 digits
Â  Â  Â  Â  Â  Â  Â  Â  handleInputChange(field, val);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  placeholder={placeholderText}
Â  Â  Â  Â  Â  Â  className={errors[field] ? "error" : ""}
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  );
Â  Â  Â  case "Double":
Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  type="text"
Â  Â  Â  Â  Â  Â  value={formData[field] || ""}
Â  Â  Â  Â  Â  Â  onChange={(e) => {
Â  Â  Â  Â  Â  Â  Â  const val = e.target.value;
Â  Â  Â  Â  Â  Â  Â  if (/^-?\d*(\.\d*)?([eE][-+]?\d*)?$/.test(val)) {
Â  Â  Â  Â  Â  Â  Â  Â  handleInputChange(field, val);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  placeholder={placeholderText}
Â  Â  Â  Â  Â  Â  className={errors[field] ? "error" : ""}
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  );
Â  Â  Â  case "BigInteger":
Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  type="text"
Â  Â  Â  Â  Â  Â  value={formData[field] || ""}
Â  Â  Â  Â  Â  Â  onChange={(e) => {
Â  Â  Â  Â  Â  Â  Â  const val = e.target.value;
Â  Â  Â  Â  Â  Â  Â  if (/^-?\d{0,19}$/.test(val)) {
Â  Â  Â  Â  Â  Â  Â  Â  handleInputChange(field, val);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  placeholder={placeholderText}
Â  Â  Â  Â  Â  Â  className={errors[field] ? "error" : ""}
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  );
Â  Â  Â  case "BigDecimal":
Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  type="text"
Â  Â  Â  Â  Â  Â  value={formData[field] || ""}
Â  Â  Â  Â  Â  Â  onChange={(e) => {
Â  Â  Â  Â  Â  Â  Â  const val = e.target.value;
Â  Â  Â  Â  Â  Â  Â  if (/^-?\d*(\.\d*)?$/.test(val)) {
Â  Â  Â  Â  Â  Â  Â  Â  handleInputChange(field, val);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  placeholder={placeholderText}
Â  Â  Â  Â  Â  Â  className={errors[field] ? "error" : ""}
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  );
Â  Â  Â  case "String":
Â  Â  Â  default:
Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  type="text"
Â  Â  Â  Â  Â  Â  value={formData[field] || ""}
Â  Â  Â  Â  Â  Â  onChange={(e) => handleInputChange(field, e.target.value)}
Â  Â  Â  Â  Â  Â  placeholder={placeholderText}
Â  Â  Â  Â  Â  Â  className={errors[field] ? "error" : ""}
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  );
Â  Â  }
Â  };

  return (
    <div className="file-upload-container">
      <div className="header">
        <Title className="file-page-title" level={2}>
          Upload Document
        </Title>
      </div>

      <form onSubmit={handleSubmit} className="upload-form">
        <div className="form-section">
          <div className="form-group">
            <label htmlFor="class-select">
              Select Class <span className="required">*</span>
            </label>
        <div className="custom-select-wrapper">
          <select
            id="class-select"
            value={selectedClass}
            onChange={handleClassChange}
            className={`custom-select ${errors.selectedClass ? "error" : ""}`}
          >
            <option value="">Select a class</option>
            {classOptions.map((name, index) => (
              <option key={index} value={name}>
                {name}
              </option>
            ))}
          </select>
        </div>

            {errors.selectedClass && (
              <span className="error-message">{errors.selectedClass}</span>
            )}
          </div>

          <div className="form-group">
            <label htmlFor="document-title">
              Document Title <span className="required">*</span>
            </label>
            <input
              id="document-title"
              type="text"
              placeholder="Enter the Document Title"
              value={documentTitle}
              onChange={(e) => setDocumentTitle(e.target.value)}
              className={errors.documentTitle ? "error" : ""}
            />
            {errors.documentTitle && (
              <span className="error-message">{errors.documentTitle}</span>
            )}
          </div>

          {/* ðŸ†• Main Document Type Dropdown */}
<div className="form-group">
  <label htmlFor="main-document-type">
    Main Document Type <span className="required">*</span>
  </label>
  <select
    id="main-document-type"
    value={mainDocumentType}
    onChange={(e) => {
      setMainDocumentType(e.target.value);
      setSubDocumentType(""); // Reset sub type when main changes
    }}
    className={`custom-select ${errors.mainDocumentType ? "error" : ""}`}
  >
    <option value="">Select Main Document Type</option>
    {mainTypeOptions.map((type, index) => (
      <option key={index} value={type}>
        {type}
      </option>
    ))}
  </select>
  {errors.mainDocumentType && (
    <span className="error-message">{errors.mainDocumentType}</span>
  )}
</div>

{/* ðŸ†• Sub Document Type Dropdown */}
<div className="form-group">
  <label htmlFor="sub-document-type">
    Sub Document Type <span className="required">*</span>
  </label>
  <select
    id="sub-document-type"
    value={subDocumentType}
    onChange={(e) => setSubDocumentType(e.target.value)}
    disabled={!mainDocumentType}
    className={`custom-select ${errors.subDocumentType ? "error" : ""}`}
  >
    <option value="">Select Sub Document Type</option>
    {subTypeOptions.map((type, index) => (
      <option key={index} value={type}>
        {type}
      </option>
    ))}
  </select>
  {errors.subDocumentType && (
    <span className="error-message">{errors.subDocumentType}</span>
  )}
</div>


{/* âœ… Show Reference Key section ONLY after a class is selected */}
{selectedClass && (
  <>
    {isReferenceKeyAutoGenerated ? (
      <div className="form-group">
        <label>Reference Key Combination</label>
        <div className="combination-box">
          {referenceKeyCombination && referenceKeyCombination.length > 0 ? (
        <ul className="reference-key-list">
          {referenceKeyCombination.map((item, index) => (
            <li key={index} className="reference-key-item">
              {item}
            </li>
          ))}
        </ul>

          ) : (
            <p className="no-combination-text">No combination fields defined.</p>
          )}
        </div>
        <small className="note-text">
          (Reference Key will be auto-generated using the above combination.)
        </small>
      </div>
    ) : (
      requiresUserReferenceKey && (
        <div className="form-group">
          <label htmlFor="reference-key">
            Reference Key <span className="required">*</span>
          </label>
          <input
            id="reference-key"
            type="text"
            placeholder="Enter a unique Reference Key"
            value={referenceKey}
            onChange={(e) => setReferenceKey(e.target.value)}
            className={errors.referenceKey ? "error" : ""}
          />
          {errors.referenceKey && (
            <span className="error-message">{errors.referenceKey}</span>
          )}
        </div>
      )
    )}
  </>
)}


        </div>

        {selectedClass && (
          <div className="form-details">
            <h3>
              {selectedClass} Details
              <span
                onClick={() => setIsAccordionOpen(!isAccordionOpen)}
                className="accordion-toggle"
              >
                {isAccordionOpen ? "â–²" : "â–¼"}
              </span>
            </h3>

            {isAccordionOpen && (
              <div className="fields-container">
                {selectedClassFields.map((field, index) => (
                  <div key={index} className="form-group">
                    <label htmlFor={`field-${field}`}>
                      {field}
                      {classStructures.find(
                        (cls) => cls.className.split(".").pop() === selectedClass
                      )?.fields[field]?.mandatory && <span className="required">*</span>}
                    </label>
                    {renderField(field)}
                    {errors[field] && (
                      <span className="error-message">{errors[field]}</span>
                    )}
                  </div>
                ))}

                <div className="form-group">
                  <label htmlFor="storageAreaId">
                    Storage Area ID <span className="required">*</span>
                  </label>
                  <input
                    id="storageAreaId"
                    type="text"
                    value={selectedStorageLocation}
                    readOnly
                    className={errors.storageAreaId ? "error" : ""}
                    placeholder="Storage ID will be auto-populated"
                  />
                  {errors.storageAreaId && (
                    <span className="error-message">{errors.storageAreaId}</span>
                  )}
                </div>
              </div>
            )}
          </div>
        )}

        <div className="file-upload-section">
          <div className="form-group">
            <label htmlFor="file-upload">
              File Upload <span className="required">*</span>
            </label>
            <div className="file-input-container">
              <input
                id="file-upload"
                type="file"
                onChange={handleFileChange}
                ref={fileInputRef}
                className={errors.file ? "error" : ""}
              />
              <div className="file-display">
                <span className="file-icon">ðŸ“„</span>
                <span className="file-name">{fileName || "Choose a file..."}</span>
                <button type="button" className="browse-button">
                  Browse
                </button>
              </div>
            </div>
            {errors.file && (
              <span className="error-message">{errors.file}</span>
            )}
          </div>
        </div>

        <div className="form-actions">
          <button type="button" className="cancel-button">
            Cancel
          </button>
          <button
            type="submit"
            className={`file-upload-button ${!isFormValid || uploading ? "disabled" : ""}`}
           disabled={!isFormValid || uploading || (requiresUserReferenceKey && !referenceKey.trim())}
          >
            {uploading ? "Uploading..." : "Upload Document"}
          </button>
        </div>
      </form>

      {/* NEW: Ant Design Modal for Loading */}
<Modal
    title="Processing Upload"
    open={isUploadingModalVisible}
    closable={false}
    footer={null}
    centered
    width={500} // Sets a fixed width for the modal
    style={{ padding: '40px', height: '300px' }} // Sets a fixed height for the modal
>
    <div style={{ textAlign: 'center',padding: '10px' }}>
        <p style={{ fontSize: '16px', color: '#555', marginBottom: '20px' }}>
            Please wait until your document is uploaded.
        </p>
        <Spin size="large" /> 
    </div>
</Modal>
    </div>
  );
};

export default FileUpload;